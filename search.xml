<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2018%2F03%2F04%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[###代理概述 生活中代理模式处处可见，例如，厂商和代理商，房东和房屋中介，当事人和律师等等这些都是代理模式的具体体现。我们可以把厂商、房东、当事人成为委托人，把代理商、房屋中介、律师成为代理人。上述的委托人和代理人的关系的共同特点就是—-代理人替委托人去执行了某些行为，并且增强了这些行为。比如，厂商没有自己去销售自己的产品，而是让自己的代理商去销售，并且代理的销售能力更加强大。房东没有自己去出租自己的房屋，而是让房产中介去出租，并且房屋中介可以更快的把房子出租出去。这就是代理模式。 编程中代理模式跟现实生活中的一样。就是使用代理对象去执行委托对象的方法，并增强委托对象的方法。代理模式主要有三个角色: 公共接口：代理类和委托类共同实现的接口。该接口声明了代理类要代理委托类执行那些方法。也称抽象角色 委托类：真正实现业务逻辑的类，也称真实角色。 代理类：替代委托类去执行抽象角色中定义的方法的类。在代理类中含有对真实角色的引用。 ###动态代理 首先在动态代理中，有两个重要的引用类型，这两者是我们理解动态代理的关键。 Proxy（类）该类的作用就是动态的生成代理类和创建代理对象。创建代理类和代理实例常用的方法static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)。 返回值为代理类实例，其中方法的参数指定了代理类的加载器，代理类要实现的接口，代理实例对代理方法的调用处理将会指派给InvocationHandle的实例。 load参数指定了动态生成的代理类的加载器，对代理类的加载我们会使用委托类的加载器。 interfaces 指定代理类要实现的接口，也就是和委托类共同接口。 h 代理实例对代理接口上的方法的调用进行处理是没有办法控制，所以我们要把方法的调用处理委托给InvocationHandle实例，在InvocationHandle实例的invoke方法，我们可以获得代理方法调用的相关信息 InvocationHandle(接口)由于代理类及其实例是在运行时生成且内置在JDK中。我们没有办法对代理类代理的方法进行控制。但是代理实例会将代理方法的调用处理继续委托给实现了InvocationHandle接口的实例。也就是每个代理实例都关联着一个用于代理方法调用处理的实例，当代理实例对代理方法进行调用时，将对方法的调用编码并指派给它的调用处理实例invoke方法。在接口InvocationHandle中就一个方法Object invoke(Object proxy, Method method, Object[] args)。 proxy —代理的实例 method—代理实例调用的代理方法的Method实例。 args—代理实例调用代理方法时传入的参数数组。如果代理方法没有参数，则为null。 上面对动态代理技术中的两个重要的数据类型做了描述，下面我们使用代码对动态代进一步理解。首先要定义一个接口来声明代理方法。123456 public interface ProxyMethod &#123;public void code();public void codeWith(String str); &#125; 接下来，我们定义一个委托类client，并实现上面的代理方法。12345678910111213141516 public class Client implements ProxyMethod&#123;@overridepublic void code()&#123; System.out.println("I love code");&#125; @overridepublic void codeWith(String str)&#123; System.out.println("I am coding with " + str);&#125; &#125; 然后我需定义一个用于处理代理方法调用的类，该类必须实现接口InvocationHandle。 123456789101112131415161718192021222324 public class InvokeHandler implements InvocationHandle &#123; //需要代理的委托类实例private ProxyMethod clientInstance;//构造方法public InvokeHandler (ProxyMethod clientInstance)&#123; this.clientInstance = clientInstance;&#125;@overridepublic Object invoke(Object object, Method method, Object[] args) throws Throwable&#123; //在委托类实例调用方法之前，我们可以添加自己的操作 System.out.println("before coding"); //委托类实例自己调用方法 method.invoke(clientInstance,args); //在委托类实例调用方法之后，添加自己的操作 System.out.println("after coding"); return null;&#125; &#125; 最后我们定义一个测试类，去测试一下效果12345678910111213141516171819202122public class Test &#123; public static void main (String[] args)&#123; //创建一个委托类对象 Client ct = new Client(); //创建一个方法调用处理类实例 InvokeHandler handler = new InvokeHandler(ct); //动态创建一个代理实例 ProxyMethod proxyInstance = (ProxyMethod)Proxy.newProxyInstance(ct.getClass().getClassLoader(), ct .getClass().getInterfaces(), handler); //打印代理实例的类型 System.out.println(proxyInstance.getClass().getName()); //代理实例调用代理方法 proxyInstance.code(); &#125;&#125; 让我们来看一下控制台的输出：1234com.sun.proxy.$Proxy0before codeI love codeafter code 我们看到动态代理类是com.sun.proxy.$Proxy0，该类与Client类实现共同的接口。所以当代理实例去调用接口中的方法，就会把方法的调用处理传递给处理程序InvokeHandler的实例。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程技术(一)]]></title>
    <url>%2F2017%2F12%2F10%2F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%BC%80%E5%90%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[声明和开启一个线程当我们创建一个线程时，必须告诉这个线程将要运行什么代码！有两种方式来实现它： 提供一个Runnable对象：Runnable是一个接口，接口定义了唯一一个方法run()，这个方法的中代码就是线程要执行的代码。当我们创建一个Thread实例的时候，需要把Runnable对象（实现了该接口的类的实例）作为Thread构造方法的参数。例如： 123456789101112131415161718public class HelloRunnable implements Runnable &#123; @override public void run ()&#123;//新线程要执行的代码 System.out.println("a thread"); &#125; public static void main(String[] args)&#123; HelloRunnable rObject = new HelloRunnable();//创建一个Runnable对象 Thread newThread = new Thread(rObject);//创建新线程，把Runnable对象作为Thread构造方法的参数 newThread.start();//启动新线程 &#125; &#125; 子类化Thread：Thread类本身实现了Runnable接口，但是Thread类中的run()没有做任何事情。所以你可以创建一个Thread类的子类，提供你自己的run的实现。 12345678910111213141516public class HelloThread extends Thread &#123; @override public void run()&#123; System.out.println("a thread"); &#125; public static void main(String[] args)&#123; HelloThread newThread = new HelloThread();//创建新线程 newThread.start();//启动新线程 &#125; &#125; 同步多个线程的之间的通信主要是通过访问共享数据，例如字段和字段引用的对象，这种通信的方式是极其方便的，但是也可能会产生两中错误—–线程干扰和内存一致性错误。阻止这些错误的工具就是同步（synchronization）。 线程干扰（Thread Interference） 思考下面的这个类Counter 12345678910111213141516class Counter &#123; private int c = 0; public void increment() &#123; c++; &#125; public void decrement() &#123; c--; &#125; public int value() &#123; return c; &#125;&#125; 在这个类中，每调用一次方法increment()成员变量c就会加1，每调用一次方法decrement()成员变量c就减1。然而，如果一个Counter 对象被多个线程引用，那么这些线程之间的相互干扰可能无法得到预期结果。 线程干扰（Thread Interference）：当两个运算作用同一个数据，且这个运算在不同的线程上运行。（注：这个两个运算是多个步骤组成的） 例如：上面代码中的表达式c++，能被分解成3步： 取出（retrieve）当前c的值 把取出的值进行加1就算 把加1计算出的值，储存到c中 当然表达式c--也会以同样的方式分解。 如果有一个线程A调用increment，与此同时另个线程B调用decrement。假如c的初始值为0。那么两个方法可能是交叉执行的，其顺序可能是这样的： Thread A: 取出c的值 Thread B: 取出c的值 Thread A: 对取出的值进行加1运算。结果为 1。 Thread B: 对取出的值进行减1运算。结果为 -1。 Thread A: 把计算的结果储存到c中，则c的值为 1。 Thread B: 把计算的结果储存到c中，则c的值为 -1。 我们可以看到最终c的值为-1，线程A的结果丢失了，被线程B重写了。上面的情况仅仅是线程干扰的一种可能，在不同的环境下，有可能线程B的结果丢失，也有可能线程没有发生干扰结果正确。由于线程干扰的结果是不可预测的，所以线程干扰导致的bugs是难以侦测和修改的。 内存一致性错误（Memory Consistency Errors） 关于什么是内存一致性错误？形象的一点说就是：当多个线程对同一个数据应该是什么样子持有不同意见（英文原文：Memory consistency errors occur when different threads have inconsistent views of what should be the same data）。内存一致性错误产生的原因是复杂的，超出我们讨论的范围。其实我们没有必要知道产生它的原因，我们只需知道如何避免它的发生就好。 理解内存一致性错误的关键是理解偏序关系（happens-before relationship），这种关系也保证了一个对内存的写操作的影响对另一个操作是可见的。为了理解它，我们看一个例子，假如有一个int类型的字段counter的声明和初始化如下 1int counter = 0; 这个字段被两个线程A，B共享，如果线程A对counter经行加1操作 1counter++; 线程B来打印counter的值。 1System.out.println(counter); 如果上面的两个语句在同一线程执行，那么输出的值为1。但是两个语句分别在两个线程中执行，那么打印的值可能是0。 因为不能保证线程A对counter的改变对线程B是可见的，除非两个语句建立了偏序关系（简单的理解就是两个语句的执行顺序） 有许多方法来建立偏序关系，其中之一就是同步（synchronization）。 同步方法​ Java语言提供两种基本的同步语法：同步方法和同步语句。 ​ 要使方法同步，只需将同步关键字synchronization添加到方法的声明中即可。 123456789101112131415public class SynchronizedCounter &#123; private int c = 0; public synchronized void increment() &#123; c++; &#125; public synchronized void decrement() &#123; c--; &#125; public synchronized int value() &#123; return c; &#125;&#125; 如果counter_obj是SynchronizedCounter的一个实例。那么对同步方法的调用会有如下影响。 如果在一线程中counter_obj 调用了某一同步方法，在另一线程中counter_obj也调用了某一同步方法，那么两个同步方法不可能在两个线程中交替执行（也就是阻止了线程干扰的可能）。只有一个线程中同步方法执行完，另一个线程的同步方法才能执行。因为当线程中counter_obj调用同步方法时，该线程就会得到counter_obj的内部锁（intrinsic lock或者minitor lock ），如果其他线程中counter_obj再调用同步方法时就会等待，直到持有counter_obj内部锁的线程把锁释放掉（即同步方法执行完） 其次，当一个同步方法存在时，它会自动与同一实例后续的同步方法调用建立偏序关系。这保证对该实例改变对其他线程是可见的。 需要注意的是构造方法不能声明为同步的，在构造方法的声明上使用synchronization关键字是语法错误。 同步语句上一节我们在讨论同步方法的时候，出现了一个概念内部锁（intrinsic lock）。在讨论同步语句之前，我们来学习一下内部锁和同步的关系。 其实同步是建立在一个名为内部锁（intrinsic lock ），也叫监视器锁（minitor lock），在API文档中也称之为监视器（minitor）。每一个实例都一个与之关联的内部锁。 当一个线程想要单独的访问某实例的字段时，线程不得不先要获得这个实例的内部锁，线程完成操作后就会释放内部锁。在线程获得内部锁和线程释放内部锁这段期间内，我们称之为线程持有内部锁。只要一线程持有某实例的内部锁，试图获得这个内部锁的其他线程那么就会阻塞。也就是同一时刻只能有一个线程持有同一内部锁。 当同步方法在线程执行时，线程就会自动的获得同步方法调用者的内部锁。同步方法返回后（也就是方法执行完毕）线程释放内部锁。你可能会有疑惑一个静态（static）的同步方法被调用将会发生什么，因为静态方法的调用者是类，而不是一个实例。因为每个类其实就是Class类的一个实例，因此每个类中也有与之相关的内部锁，当调用静态同步方法的时候，线程会自动获得当前类的内部锁。 下面我们看看同步语句的语法： 1234567public void addName(String name) &#123; synchronized(this) &#123; lastName = name; nameCount++; &#125; nameList.add(name);&#125; 在上面的例子中我们能看到，首先，与同步方法不同，同步语句必须指定提供内部锁的实例。其次，addName 方法同步 改变lastName和nameCount，又避免了同步调用其他实例方法，这里的“其他实例方法的调用”指的是nameList.add(name)，因为在同步代码中调用其他实例的方法可能产生被称为liveness的问题（以后我们会讨论这个问题）。所以同步在并发时能够实现更细粒度的同步。 下面我们再看一个例子 123456789101112131415161718public class MsLunch &#123; private long c1 = 0; private long c2 = 0; private Object lock1 = new Object(); private Object lock2 = new Object(); public void inc1() &#123; synchronized(lock1) &#123; c1++; &#125; &#125; public void inc2() &#123; synchronized(lock2) &#123; c2++; &#125; &#125;&#125; 类MsLunch有两个个字段C1和C2，它们永远不会同时使用。这些字段的所有更新必须同步，但允许他们更新时能够交错执行。我们就可以像例子那样，使用两个对象提供锁，以代替同步方法和使用this的同步语句。这样减少了不必要的阻塞增加了并发性。 可重入同步通过前面的学习我们知道，一个线程不能获得以被其他线程持有的内部锁，但是一个线程能够再次获得自已已持有的锁。也就是说同一线程可以多次获得同一把内部锁，这保证可重入同步。留一个思考，想想下面的描述的场景如果不支持可重入同步将会发生什么现象？——–当同步代码中直接或者间接的调用了一个方法，而这个方法也有同步代码，并且这两个同步代码使用的是同一把锁。 本文简单介绍了Java语言怎么声明和开启一个线程，以及同步的相关基础知识。有关多线程的技术下次再写！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类的概念和创建概念 ：内部类就是将一个类的定义置于另一个类的定义的内部。 123456public class Outer&#123; class Inner&#123; &#125; &#125; 如上面的例子：类Inner的定义放在类Outer的定义的内部了。 那么如何来创建内部类对象呢？ 内部类对象的创建必须依赖外围类的对象！ 123Outer outerObj = new Outer();//创建外围类的对象Outer.Inner innerObj = outerObj.new Inner();//创建内部类对象//如果通过上述的方式创建内部类不需要import内部类. 另外一种方式 12345Outer outerObj = new Outer();//创建外围类的对象Inner innerObj = outerObj.new Inner();//创建内部类对象//如果是上述方式这么写,那么在该文件导包导入该内部类。比方Outer类在包coding.me中，则需要像下面这样导包// import coding.me.Outer.Inner 内部类和外部类的链接 当一个外部类的对象创建一个内部类对象时，此内部类对象会捕获一个指向外部类对象的引用，我们可以在内部类中使用OuterClassName.this来获得对外部类对象的引用。而且内部类拥有对外部类所有成员的访问权限 内部类访问外部类的成员变量 123456789101112131415public class Outer&#123; public String member1 = "成员_one"; class Inner&#123; //内部类的成员方法 public void inner_method1 &#123; //访问外围类的成员变量---member1 System.out.println("外部类的成员：" + member1); &#125; &#125; &#125; ​ 12345678910111213141516public class Test &#123; public static void main(String[] args)&#123; Outer outerObj = new Outer();//创建外部类的对象 Outer.Inner innerObj = outerObj.new Inner();//创建内部类对象 innerObj.inner_method1(); &#125; &#125;结果：外部类的成员：成员_one 在上面的例子中我们看到：在内部类Inner中可以直接访问外部类Outer的成员member1而不加任何修饰和限定。但是如果内部类Inner中同样也有一个名为member1的成员呢，我们该怎么来区分？看下面的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Outer&#123; //外部类的成员 public String member1 = "outer_成员_one"; class Inner&#123; //内部类的成员 public String member1 = "inner_成员_one"; //内部类的成员方法 public void inner_method1 &#123; //访问外部类的成员变量---member1 System.out.println("外部类的成员：" + Outer.this.member1); //访问内部类的成员变量---member1 System.out.println("内部类的成员：" + member1); &#125; &#125; &#125;public class Test &#123; public static void main(String[] args)&#123; Outer outerObj = new Outer();//创建外部类的对象 Outer.Inner innerObj = outerObj.new Inner();//创建内部类对象 innerObj.inner_method1(); &#125; &#125; 结果：外部类的成员：outer_成员_one 内部类的成员：inner_成员_one 内部类访问外部类的成员方法 在内部类中访问外部类的成员方法与访问成员变量一样，不在赘述！ 局部内部类​ 通过上面对内部类都是定义在外部类的类中方法外，内部类可以定义方法里面（其实内部类可以定义类中的任何作用域中）。定义在方法中的内部类称为局部内部类 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Outer &#123; int i = 12; public void outer_method1() &#123; int i = 10; //局部内部类 class LocalInner&#123; int i = 11;//如果注释掉这行代码，输出结果怎样？ public void localInner_method1() &#123; System.out.println("局部内部类：localInner" +","+ "局部变量："+ i ); System.out.println("局部内部类：localInner" +","+ "内部类成员变量："+ this.i );//如果注释掉 int i = 11,这行代码编译错误 System.out.println("外部类：Outer" +","+ "外部类成员变量："+ Outer.this.i ); &#125; &#125; LocalInner localInner_obj = new LocalInner(); localInner_obj.localInner_method1(); &#125; &#125;class Test &#123; public static void main(String[] args)&#123; Outer outerObj = new Outer(); outerObj.outer_method1(); &#125; &#125;结果：局部内部类：localInner,局部变量：11 //根据输出的结果发现，局部变量并不是10，而是内部类的成员11 局部内部类：localInner,内部类成员变量: 11 外部类：Outer,外部类成员变量: 12 /*根据输出的结果，可知当局部内部类的成员变量和方法内的局部变量同名时，我们是无法区分的！*/ //如果注释掉局部内部类中的 int i = 11;这行的代码，则输出结果为： 局部内部类：localInner,局部变量：10 外部类：Outer,外部类成员变量: 12 /*如果注释掉 int i = 10；*/ 如上所示，内部类LocalInner定义在方法内部，LocalInner既为局部内部类，而且LocalInner只能在方法outer_method1中使用。对于局部内部类的使用有两点需要注意： 如果局部内部类截获了，局部变量！ 那么这个局部变量就会变成常量，即变量会被final修饰限制 局部内部类不能有权限修饰符。 匿名内部类123456789101112131415161718192021222324252627282930313233343536373839404142public class A &#123; public static void main(String[] args)&#123; B obj_b = new B(); obj_b.method_b(); &#125; public int value()&#123; System.out.println("A类的方法"); return 1; &#125; &#125;class B &#123; public void method_B () &#123; A obj_a = new A()&#123; private int a_member = 12; public int value()&#123; System.out.println("A类的子类重写的方法"); return 10; &#125; &#125;; obj_a.value(); &#125; &#125;&#125;//运行结果为:A类的子类重写的方法 类B的成员方法method_b()中的代码有点奇怪，它即创建对象，又有类的定义。这种语法真正的含义是：创建一个继承A类的子类对象，但是这个子类（匿名类）没有名字 。new A()后面的代码即为该子类的定义。创建的这个对象的引用向上转型为父类类型（A）。 上面在创建匿名内部类对象时，使用的无参构造new A()，如果需要父类的参构造怎么办？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class A &#123; public static void main(String[] args)&#123; B obj_b = new B(); obj_b.method_b(); &#125; public A (int x)&#123; System.out.println("有参构造：参数" + x); &#125; public int value()&#123; System.out.println("A类的方法"); return 1; &#125; &#125;class B &#123; public void method_B () &#123; int i = 10； A obj_a = new A(i)&#123; private int a_member = 12; public int value()&#123; System.out.println("A类的子类重写的方法"); return 10; &#125; &#125;; obj_a.value(); &#125; &#125;&#125;//运行结果：有参构造：参数10// A类的子类重写的方法 嵌套类（静态内部类）上面我们介绍了普通内部类，局部内部类，匿名内部类。这些内部类对象都与外部类对象有联系，即在内部类实例中隐式的保存了一个指向外部类实例的引用—–OuterClassName.this，通过该引用我们可以在内部类中访问到外部类的成员和方法。但是如果我们不需要内部类对象和外部类对象的之间的联系，那么我们可以使用static来修饰内部类。这通常成为嵌套类 。 嵌套类意味着： 创建嵌套类对象，不依赖于外部类对象。 不能从嵌套类对象中访问非静态的外部对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TestStaticInner &#123; public static int x = 13; public static class nestClass &#123; private int i = 10; public void value() &#123; System.out.println(x);//访问外部类的静态成员 System.out.println(i); abc();//访问外部类的静态方法 &#125; &#125; public static void abc() &#123; System.out.println("hhh"); &#125; public void testMethod() &#123; nestClass nClass = new nestClass(); nClass.value(); &#125; public static void main(String[] args) &#123; TestStaticInner te = new TestStaticInner(); te.testMethod(); &#125;&#125;/* 运行结果：10 13 hhh*/ 有关内部类的知识先写这么多！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四月]]></title>
    <url>%2F2017%2F05%2F04%2F%E5%9B%9B%E6%9C%88%2F</url>
    <content type="text"><![CDATA[一身诗意千寻瀑，万古人间四月天]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift之类型转换]]></title>
    <url>%2F2016%2F06%2F15%2Fswift%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Type-Casting Operatorsswift中定义了四种类型转换操作符分别是:is(实际是用于类型检查),as,as!和as?。它们的类型转换的表达式格式分别为： espression is typeespression as typeespression as! typeespression as? type is是用来作类型检查的。用来判断左边的espression的值（一个类的实例）是否属于右边type的子类。如果属于type的子类，那么返回true，否则返回false as是向上类型转换（upcasting）。把espression的值的类型向它的父类类型（superType）转换。使用as要保证在编译阶段总是success as！ 是向下类型转换（downCasting）。espression的值的类型向它的子类类型（subclass）转换。在运行时（runtime）阶段，as！ 会强制类型转换，如果类型转换失败，就会产生一个运行时错误 as？ 也是向下类型转换（downCasting）。espression的值的类型向它的子类类型转换。在运行时阶段，as? 如果类型转换成功，espression的值会被包装（wrap）一个可选类型并返回；如果类型转换失败，就会返回nil example of as123456789101112131415161718192021222324252627282930313233class Person&#123; var age: Int? var name: String? var dog: SheepDog? &#125;class Dog&#123; var colorOfHair: String?&#125;class SheepDog: Dog&#123; var sheeps: Int? &#125;let p = Person() //创建一个Person实例p p.dog = SheepDog() let d = p.dog as Dog?/*1. as 把一个SheepDog？转换成一个父类的Dog？类型 2.同样可以使用let d = p.dog! as Dog进行类型转换 3.如果我们使用let d = p.dog as? Dog? 或者 let d = p.dog as！Dog? 来进行转换，Xcode会总是转换成功的报警告！ 注：根据官方文档描述“If casting to the specified type is guaranteed to fail or is guaranteed to succeed, a compile-time error is raised.”。Xcode应该会产生一个编译错误的，但是Xcode却产生了警告 */ print(d！)//d的类型是Dog？（编译阶段），但是在运行时还是检查它的真实类型的--SheepDog 根据上面的例子也可以看出，as是用于upcasting，如果upcasting使用了as? 或者 as！ Xcode会报⚠️（官方文档说会报错误）！ example of as？and as!把上面Person类改动一下，其他类不变123456789101112131415161718192021class Person&#123; var age: Int? var name: String? var dog: Dog? &#125;let p = Person()p.dog = SheepDog()let d = p.dog as? SheepDog/*1.as？把一个Dog?类型的值转换成它的子类--SheepDog类型，并把这个SheepDog类型的值包装在一个可选值里面然后返回给d，所以d的类型为SheepDog?*/print(d!)/*如果上面的as？类型转换失败，那么对d解包会返回一个nil，运行报错*//*1.如果把上面let d = p.dog as? SheepDog这行代码替换成let d = p.dog as！SheepDog 那么转换成功后，直接返回一个SheepDog类型的值给d，不会进行可选包装。如果转换失败，则返回nil，运行报错。2.如果把上面let d = p.dog as? SheepDog这行代码替换成let d = p.dog as SheepDog？或者 d = p.dog！ as SheepDog或者 d = p.dog as SheepDog，都会编译错误！因为as是upcasting，不能用于downcasting*/ 操作符is比较简单,不再举例以上是我对对于swift类型转换的理解，遂形成文字以作记录！如有理解错误之处，请各位给予指教，多谢！]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[url编码]]></title>
    <url>%2F2016%2F06%2F02%2Furl%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[最近两天在研究关于URL编码的问题，如果想要了解这方面知识可以参考文档RFC3986。当然国内也有把该文档进行翻译的中文版RFC3986中文版， URL合法字符首先，URL合法字符并不支持所有的字符。其次，URL合法字符也不支持US-ASCII字符集中所有的字符！URL合法字符集只是US-ASCII的一个子集。那么，URL合法字符包含哪些呢？ uppercase and lowercase letters 即大小写字母，a~z 和A~Z decimal digits 即 0~9 hyphen, period, underscore, and tilde 即 - . _ ~四个字符 revserved characters 即保留字符: / ? # [ ] @ ! $ &amp; &#39; ( ) * + , ; = 保留字符在URL合法字符集中,有一些字符被预留用于特定的作用–用来分割URL组件或者子组件,这些字符就是reversved characters(保留字符)。URL保留字符集上面已给出这里不再赘述。一般的URL通常由scheme，authority，path，query，fragment几个components(组件)组成。例如： 那么: / ? #都是用来分割组件的，不是URL数据(data)的一部分! Percent-EncodingURL支持的合法的字符那么少，如果URL中出现了中文，特殊符号等这些不安全字符怎么办,解决的办法就是Percent-Encoding机制！当代表URL的字符串中出现不合法字符,或者在URL的组件中出现保留字符作为组件数据,那么都需要对这些字符进行Percent-Encoding.例如:http://wdluya.cn/文档/frchttp://wdluya.cn/document/rfc?index={&quot;name&quot;:&quot;RFC3986&quot;} 在第一个例子中出现了中文,URL不支持.所以要进行编码 第二个例子中在query组件中出现了保留字符&quot; :作为组件数据,所以也要进行编码]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQLite的原子提交和事务]]></title>
    <url>%2F2016%2F04%2F04%2FSQLite%E7%9A%84%E5%8E%9F%E5%AD%90%E6%8F%90%E4%BA%A4%E5%92%8C%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[SQLite是事务性数据库,事务性数据库的一个重要的特性就是原子提交(atomic commit),所谓的原子提交就是:在一个事务中数据库的变化，要么都发生，要么一个也不发生。 要想了解SQLite原子提交的过程，首先必须了解SQLite中的锁 sqlite中的锁从单个进程的观点来看，对于该进程来说，数据库文件总是处于下面五个锁状态之一 未加锁(UNLOCKED) 在这个状态下,数据库既没有被读也没有被写 共享锁(SHARE) 在共享锁的状态下,数据正在被读但是没有被写。多个进程可以在同一时间对数据库持有共享锁。 保留锁(RESERVED) 一个保留锁意味着———某个进程将要对数据库进行写操作，但当前还在对数据库进行读操作。数据库只能有一个保留锁，这个保留所能和多个共享锁共存。也就是说在保留锁的情况下，其他进程可以对数据库读，但是不能尝试对数据库写。 未决锁(PENDING) 未决锁意味着——–对数据库持有未决锁的进程马上要对数据库进行写操作，但是由于其他进程还对数据库进行读操作（也就是其他进程对数据库持有共享锁）,所以该进程要等待其他的进程的共享锁都释放。一旦其他进程的共享锁释放，那么该进程就会拿到独占锁。未决锁和保留锁的区别是：在保留锁的状态下，新的共享锁还能够创建；然而在未决锁状态下，新的共享锁不能被创建了 独占锁(EXCLUSIVE) 为了能够对数据库进行写，独占锁是必须的。只有在独占锁状态下才能对数据库进行写操作，任何锁都不能与独占锁共存。为了最大限度地提高并发性，SQLite最小化了独占锁的持有时间 单个文件的提交 初始状态 当一个数据库连接被打开的时候，从概念上讲，所示如下图: 右边代表存储着数据的磁盘。每个长方形代表着一个sector，蓝色代表着sector存储着的是原始信息。 中间是操作系统的磁盘缓存。这时候的缓存是冷缓存，简单的说就是让磁盘缓存的sector保存为空。 左边显示的是正在使用SQLite的进程的用户内存空间 因为数据库连接仅仅是被打开还没有读取数据，所以用户空间是空的！这时候数据处于未加锁状态。 获取读锁 在能够对数据进行写操作之前，进程必须首先要对数据库进行读操作。也就是说哪怕进程只是向数据库中添加数据，那么它也必须先数据库进行读，以至于它能知道怎么解析INSERT语句和新的数据要被存储到数据文件中的位置。 当对数据库读的时候，进程就对数据库上了一把锁—-共享锁（share lock）。如果所示共享锁是在操作系统磁盘缓存上而非磁盘数据文件上。 从数据库中读取信息 当共享锁获得之后，我们就能从数据库文件中读取数据了。 获取保留锁 在对数据库写之前，先要给数据库上一把保留锁（reserved lock）。保留锁意味着：进程不久的将来要对数据库文件进行修改，但是现在还没有开始修改。因为还没开始修改数据库，所以保留锁允许其他进程读数据库。 创建回滚日志文件 获取保留锁后，SQLite会创建一个单独的回滚日志文件，然后把将要改变的内容写到回滚日志文件中。 在用户内存空间改变数据库的页 当把将要改变的数据保存到回滚日志文件中后，数据库的页将在用户的内存空间被改变。 把回滚日志文件复制到磁盘 当数据库的页在用户空间中被改变后，接下来就是要将在操作系统缓存中的日志文件，复制到磁盘上。 获得独占锁 在对数据库文件进行修改的之前，我们必须给数据库上一把独占锁（exclusive lock）。其实对于获取独占锁分为两个过程：首先，SQLite获取一个未决锁（pending lock）然后未决锁在升级为独占锁。 把变化写入数据库文件中 一旦获得独占锁后，我们就知道没有其他的进程在数据库进行读了，这时候我们把变化写入数据库文件中是安全的，其实这时候我们只是把变化写到了操作系统的磁盘缓存中。 把变化复制到磁盘文件中 这一步非常重要，就是要把变化从缓存中复制到磁盘文件中。把变化从系统缓存中复制到磁盘是比较慢的一个过程。这一步和第7步占据了整个提交过程的大部分时间。 删除回滚日志 当变化安全的从缓存中复制到磁盘上以后，回滚日志就会被删除！ 释放独占锁 提交过程的最后一步就是释放独占锁，以至其他的进程能开始访问数据库 事务控制在默认情况下，SQLite3的操作都是在自动提交的模式下，也就是说，一旦对数据库的操作完成就立即会把变化提交！ SQL命令BEGIN TRANSACTION(关键字TRANSACTION是可选的)会使SQLite退出自动提交模式，直到遇到COMMIT命令才会把变化提交. SQL命令COMMIT实际上不是真正变化提交到磁盘文件(数据库文件)中，而是让SQLite 重新回到自动提交模式。变化被提交到磁盘文件中的发生——由自动提交模式的逻辑接管。 当SQL命令COMMIT打开自动提交模式，然后SQL自动提交模式的逻辑试着提交变化但是失败了。这是因为这时候其他的进程对持有数据库一个分享锁（SHARE） 在自动提交模式下: lite1234//下面是SQLite的伪代码db = open("foods");db.exec("insert into drinks name values 'orange juice'");db.exec("insert into fruits name values 'apple'"); 每一个insert语句是在一个单独的事务中,所以上面数据库的状态的变化为: UNLOCKED —- SHARE—–RESERVED—-PENDING—-EXCLUSIVE—-UNLOCKED —- SHARE—–RESERVED—-PENDING—-EXCLUSIVE。每当一个命令执行完，数据库都会把变化提交。 lite123456//db = open("foods");db.exec("BEGIN");db.exec("insert into drinks name values 'orange juice'");db.exec("insert into fruits name values 'apple'");db.exec("COMMIT") 如果使用使用命令BEGIN和COMMIT那么事务的有我们自己来管理： UNLOCKED —- SHARE—–RESERVED—-PENDING—-EXCLUSIVE]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods(一)]]></title>
    <url>%2F2016%2F03%2F01%2FCocoaPods%2F</url>
    <content type="text"><![CDATA[CocoaPods是什么?CocoaPods是为我们的Xcode projects 管理库依赖的工具 。当你的project开发时需要引用第三方库的，你只需将project所依赖的库名添加到一个名为Podfile的纯文本文件中。CocoaPods将会获取project所依赖的库的源代码，并把这些库链接到同一个Xcode workspace来构建你的project。 安装CocoaPodsCocoaPods是用脚本语言Ruby构建的。macOS默认是安装Ruby环境的，你可以使用系统自带的Ruby环境来安装CocoaPods。 1$ sudo gem install cocoapods gem是ruby的包管理工具! 如果gem的版本过低在安装cocoapods时会出问题.使用 $sudo gem update –system来更新gem 注意在执行上面的命令之前,我们需要替换一下ruby的软件源。ruby官方的软件源是https://rubygems.org/,我们可以通过下面的命令查看当前ruby环境的软件源是什么 1$ gem sources -l 因为官方的软件源是被墙，所以我们要替换一下。操作如下：首先删除默认的软件源 1$ gem sources --remove https://rubygems.org/ 添加Ruby China维护的软件源 1$ gem sources -a https://gems.ruby-china.org/ 注：之前淘宝也维护着RubyGems，但是现在不在维护，所以之前使用淘宝源的，应该替换成Ruby China的。 安装了CocoaPods后，我们还需要执行下面的命令 1$ pod setup 当执行pod setup时，CocoaPods就创建~/.cocoapods/respos目录，然后从GitHub CocoaPods仓库里把所有的Podspec克隆到该目录下（也就是把github上CocoaPods仓库的master分支拷贝下来）。由于拷贝的文件较大（一百多兆），需要稍等会！ what is PodSpec？后面我们后讲到 更新CocoaPods如果你要更新CocoaPods的版本,同安装命令一样 1$ sudo gem install cocoapods 在项目中使用CocoaPods在macOS上已经安装了CocoaPods。接下来我们来学习怎么样在Xcode中使用CocoaPods。对于在项目中使用CocoaPods可以按照下面的步骤： 创建你的Xcode project 打开终端，使用$ cd命令进入你创建的project根目录 创建一个名为Podfile的文件，对于创建该文件可以使用命令$ pod init 打开Podfile文件，第一行指定平台和支持的版本 platform : ios, &apos;9.0&apos; 为了使用CocoaPods, 你应该声明Xcode project中的哪个Xcode target 和CocoaPods链接。 target &apos;$TATGET_NAME&apos; do end 在Podfile文件中单独一行通过pod &#39;$PODNAME&#39;来添加一个pod target &apos;MyApp&apos; do pod &apos;AFNetworking&apos; end 编辑完了Podfile文件，进行保存。 运行 $ pod install 这时候你就会发现你的project目录下面多了一个MyApp.xcworkspace文件。然后打开这个文件就可以码你的project了。 使用pod install vs pod update许多人对什么时候pod install 和 pod update是迷惑的。他们经常在该使用pod install的时候使用了pod update。这张就来讨论一下两者的区别： 使用pod install是用来安装新的pod到你的project中的。即使你之前已经有Podfile文件并且运行了pod install。因此在已经使用了CocoaPods的项目中，pod install只是向你的project中添加或者删除pod。 使用pod update [POD_NAME]只是在你需要pods更新到一个新版本的时候 注意：pod install和pod update都不是作用于CocoaPods这个工具软件的安装和更新。而是作用于Podfile文件中描述的pod（就是project所依赖的第三方库）的安装和更新。 pod install这个命令在两个时候用： 第一次为你的project安装pod的时候 当你再次编辑Podfile，在文件中添加，删除，更新pods的时候 每次运行pod install的时候，CocoaPods就会为project去下载并安装pods。安装完毕后，CocoaPods会将每个pod的版本信息写入一个名为Podfile.lock的文件中。这个文件记录这每个pod的版本并锁着这些版本pod。 当运行pod install时，CocoaPods只解决在Podfile.lock中没有记录的pods的依赖问题。 如果pod在Podfile.lock中记录了，那么CococaPods就会下载Podfile.lock记录的某个版本的pod,不会试图去检查pod是否有可有的新版本。 如果pod没有在Podfile.lock中记录，CocoaPods将会根据Podfile描述的版本检索相应的pod进行安装 pod outdated如果你运行pod outdated,CocoaPods就会罗列出Podfile.lock中所记录pod（也就是当前project已经安装的pods）的新版本。这样你就知道了哪些pods有了新版本，以便于运行pod update $PODNAME来更新项目中的pods。 注：运行pod update $PODNAME来更新pod时，新版pod的版本号必须满足Podfile对pod的设置，例如pod &#39;MyPod&#39;, &#39;~&gt;x.y&#39;。 pod update当你运行pod update $PODNAME的时候，CocoaPods试图找到名字为PODNAME的pod的新版本进行安装，不会考虑Podfile.lock中锁定的pod的。 如果运行pod update，那么CocoaPods将会试图更新Podfile中列举所有的pod。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>​</tag>
      </tags>
  </entry>
</search>